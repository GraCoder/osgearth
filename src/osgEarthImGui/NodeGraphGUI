/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#pragma once

#include <osgEarthImGui/ImGuiPanel>
//#include <third_party/imgui/misc/cpp/imgui_stdlib.h>

#if defined(__has_include)
#if __has_include(<third_party/portable-file-dialogs/portable-file-dialogs.h>)
#include <third_party/portable-file-dialogs/portable-file-dialogs.h>
#define HAS_PFD
#endif
#endif


#include <osgEarthProcedural/ProceduralTiledModelLayer>

namespace osgEarth
{
    namespace Procedural
    {
        using namespace osgEarth;

        class NodeGraphGUI : public ImGuiPanel
        {
        private:
            osg::observer_ptr< MapNode > _mapNode;
            osg::observer_ptr< ProceduralTiledModelLayer > _proceduralModelLayer;
            bool _autoUpdate = false;

        public:
            NodeGraphGUI() : ImGuiPanel("NodeGraph")
            {
            }

            void DrawMenuBar()
            {
                if (ImGui::BeginMenuBar())
                {
                    if (ImGui::BeginMenu("File"))
                    {                       
                        if (ImGui::MenuItem("Open"))
                        {
                            auto f = pfd::open_file("Node Graph", pfd::path::home(),
                                                               { "All Files", "*" });

                           
                            if (!f.result().empty())
                            {
                                osg::ref_ptr<XmlDocument> doc = XmlDocument::load(f.result()[0]);
                                if (doc.valid())
                                {
                                    auto nodeGraph = NodeGraph::fromConfig(doc->getConfig());
                                    _proceduralModelLayer->setNodeGraph(nodeGraph);
                                    auto state = nodeGraph->userConfig.value("imgui_state");
                                    if (!state.empty())
                                    {
                                        ImNodes::LoadCurrentEditorStateFromIniString(state.c_str(), state.length());
                                    }   
                                }
                            }
                        }

                        if (ImGui::MenuItem("Save As"))
                        {
                            auto f = pfd::save_file("Node Graph", pfd::path::home(),
                                { "All Files", "*" });

                            if (!f.result().empty())
                            {
                                auto graph = _proceduralModelLayer->getNodeGraph();
                                graph->userConfig.set("imgui_state", ImNodes::SaveCurrentEditorStateToIniString());
                                Config config = graph->getConfig();
                                std::ofstream out(f.result());
                                osg::ref_ptr<XmlDocument> xml = new XmlDocument(config);
                                xml->store(out);
                            }
                        }

                        ImGui::EndMenu();
                    }

                    if (ImGui::BeginMenu("Add Node"))
                    {
                        if (ImGui::MenuItem("Sphere"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<SphereOperation>());
                        }

                        if (ImGui::MenuItem("Transform"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<TransformOperation>());
                        }

                        if (ImGui::MenuItem("Float"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<FloatValue>());
                        }

                        if (ImGui::MenuItem("Color"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<ColorValue>());
                        }

                        if (ImGui::MenuItem("Join Nodes"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<JoinNodesOperation>());
                        }

                        if (ImGui::MenuItem("Simplify"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<SimplifyOperation>());
                        }

                        if (ImGui::MenuItem("Random Points"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<RandomPointsOperation>());
                        }

                        if (ImGui::MenuItem("Points On Edge"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<PointsOnEdgeOperation>());
                        }

                        if (ImGui::MenuItem("Gridded Points"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<GriddedPointsOperation>());
                        }

                        if (ImGui::MenuItem("Place Nodes"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<PlaceNodesOperation>());
                        }

                        if (ImGui::MenuItem("Features to Lines"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<FeaturesToLinesOperation>());
                        }

                        if (ImGui::MenuItem("Features to Polygons"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<FeaturesToPolygonsOperation>());
                        }

                        if (ImGui::MenuItem("Extrude Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<ExtrudeOperation>());
                        }

                        if (ImGui::MenuItem("Random Value Per Feature"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<RandomValuePerFeature>());
                        }

                        if (ImGui::MenuItem("Random Color Per Feature"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<RandomColorPerFeature>());
                        }

                        if (ImGui::MenuItem("Current LOD"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<CurrentLODOperation>());
                        }

                        if (ImGui::MenuItem("Comparison"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<ComparisonOperator>());
                        }

                        if (ImGui::MenuItem("Clamp Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<ClampFeaturesOperation>());
                        }

                        if (ImGui::MenuItem("Buffer Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<BufferOperation>());
                        }

                        if (ImGui::MenuItem("Offset Curve Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<OffsetCurveOperation>());
                        }

                        if (ImGui::MenuItem("Offset Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<OffsetFeaturesOperation>());
                        }

                        if (ImGui::MenuItem("Filter Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<FilterFeaturesOperation>());
                        }

                        if (ImGui::MenuItem("Select Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<SelectFeaturesOperation>());
                        }

                        if (ImGui::MenuItem("Feature Ouptut"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<FeatureOutputOperation>());
                        }

                        if (ImGui::MenuItem("OSM Highways Color"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<OSMHighwaysColorOperation>());
                        }

                        if (ImGui::MenuItem("Polygons to Points"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<PolygonToPointsOperation>());
                        }

                        if (ImGui::MenuItem("Points Along Geometry"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<PointsAlongGeometryOperation>());
                        }

                        if (ImGui::MenuItem("Image Mask"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<ImageMaskOperation>());
                        }

                        if (ImGui::MenuItem("Image From Layer"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<ImageFromLayerOperation>());
                        }

                        if (ImGui::MenuItem("Get Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<GetFeaturesOperation>());
                        }

#ifdef HAS_PFD                                
                        if (ImGui::MenuItem("Load Image"))
                        {
                            auto f = pfd::open_file("Image", pfd::path::home(),
                                { "All Files", "*" },
                                pfd::opt::multiselect);

                            if (f.result().size() > 0)
                            {
                                for (auto const& name : f.result())
                                {
                                    _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<LoadImageOperation>(name));
                                }
                            }
                        }
#endif

#ifdef HAS_PFD                                
                        if (ImGui::MenuItem("Load Node"))
                        {
                            auto f = pfd::open_file("Node", pfd::path::home(),
                                { "All Files", "*" },
                                pfd::opt::multiselect);

                            if (f.result().size() > 0)
                            {
                                for (auto const& name : f.result())
                                {
                                    _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<LoadNodeOperation>(name));
                                }
                            }
                        }
#endif

#ifdef HAS_PFD                                
                        if (ImGui::MenuItem("Load Features"))
                        {
                            auto f = pfd::open_file("Features", pfd::path::home(),
                                { "All Files", "*" },
                                pfd::opt::multiselect);

                            if (f.result().size() > 0)
                            {
                                for (auto const& name : f.result())
                                {
                                    _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<LoadFeaturesOperation>(name));
                                }
                            }
                        }
#endif

                        if (ImGui::MenuItem("Join Features"))
                        {
                            _proceduralModelLayer->getNodeGraph()->operations.push_back(std::make_shared<JoinFeaturesOperation>());
                        }

                        ImGui::EndMenu();
                    }
                }
                ImGui::EndMenuBar();
            }

            void DrawToolbar()
            {
                if (ImGui::Checkbox("Auto Update | ", &_autoUpdate))
                {
                    // Go ahead and do an update if we are turning on auto update
                    if (_autoUpdate)
                    {
                        //_proceduralModelLayer->dirty();
                        _proceduralModelLayer->dirtyNodeGraph();
                    }
                }

                // Show an Update button to manually refresh the node graph if auto update is off.
                ImGui::SameLine();
                if (ImGui::Button("Update"))
                {
                    _proceduralModelLayer->dirty();
                    //_proceduralModelLayer->dirtyNodeGraph();
                }
            }

            void updateNodeGraph()
            {
                if (_autoUpdate)
                {
                    _proceduralModelLayer->dirtyNodeGraph();
                }
            }

            void draw(osg::RenderInfo& ri) override
            {
                if (!isVisible())
                    return;

                if (!findNodeOrHide(_mapNode, ri))
                    return;

                if (!_proceduralModelLayer.valid())
                {
                    _proceduralModelLayer = _mapNode->getMap()->getLayer<ProceduralTiledModelLayer>();                 
                    if (!_proceduralModelLayer.valid())
                    {
                        _proceduralModelLayer = new ProceduralTiledModelLayer();
                        _mapNode->getMap()->addLayer(_proceduralModelLayer.get());
                    }
                }

                if (ImGui::Begin(name(), visible(), ImGuiWindowFlags_MenuBar))
                {
                    // Capture the keyboard so we can use the delete key
                    ImGui::SetNextFrameWantCaptureKeyboard(true);

                    DrawMenuBar();

                    DrawToolbar();                    

                    ImNodes::BeginNodeEditor();

                    if (_proceduralModelLayer.valid())
                    {
                        for (auto& o : _proceduralModelLayer->getNodeGraph()->operations)
                        {
                            ImNodes::BeginNode(o->getId());
                            ImNodes::BeginNodeTitleBar();
                            ImGui::TextUnformatted(o->getName().c_str());
                            ImNodes::EndNodeTitleBar();

                            FloatValue* floatValue = dynamic_cast<FloatValue*>(o.get());
                            if (floatValue)
                            {
                                float v = floatValue->getValue();
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::InputFloat("Value", &v, 0.0f, 0.0f, "%.5f"))
                                {
                                    floatValue->setValue(v);
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            SphereOperation* sphere = dynamic_cast<SphereOperation*>(o.get());
                            if (sphere)
                            {
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::ColorEdit4("Color", (float*)sphere->color._v, ImGuiColorEditFlags_NoInputs))
                                {
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            ColorValue* colorValue = dynamic_cast<ColorValue*>(o.get());
                            if (colorValue)
                            {
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::ColorEdit4("Color", (float*)colorValue->color._v, ImGuiColorEditFlags_NoInputs))
                                {
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }                            

                            ImageMaskOperation* imageMask = dynamic_cast<ImageMaskOperation*>(o.get());
                            if (imageMask)
                            {
                                ImGui::PushItemWidth(100.0f);

                                if (ImGui::ColorEdit4("Color", (float*)imageMask->color._v, ImGuiColorEditFlags_NoInputs))
                                {
                                    updateNodeGraph();
                                }

                                float tolerance = imageMask->getTolerance();
                                if (ImGui::SliderFloat("Tolerance", &tolerance, 0.0f, 1.0f))
                                {
                                    imageMask->setTolerance(tolerance);
                                    updateNodeGraph();
                                }

                                ImGui::PopItemWidth();
                            }

                            ImageFromLayerOperation* imageFromLayer = dynamic_cast<ImageFromLayerOperation*>(o.get());
                            if (imageFromLayer)
                            {
                                ImGui::PushItemWidth(100.0f);

                                std::string layerName = imageFromLayer->getLayerName();
                                static char layerNameChar[1024];
                                strcpy(layerNameChar, layerName.c_str());
                                if (ImGui::InputText("Layer", layerNameChar, IM_ARRAYSIZE(layerNameChar)))
                                {
                                    imageFromLayer->setLayerName(std::string(layerNameChar));
                                    updateNodeGraph();
                                }

                                ImGui::PopItemWidth();
                            }

                            if (auto* getFeatures = dynamic_cast<GetFeaturesOperation*>(o.get()))
                            {
                                ImGui::PushItemWidth(300);

                                std::vector<osg::ref_ptr<FeatureSource>> layers;
                                _mapNode->getMap()->getLayers<FeatureSource>(layers);
                                std::vector<const char*> layer_names;
                                for(auto& layer : layers)
                                    layer_names.emplace_back(layer->getName().c_str());
                                if (layer_names.size() > 0)
                                {
                                    static int current_item = 0;

                                    if (getFeatures->getLayerName().empty())
                                        getFeatures->setLayerName(layer_names[current_item]);

                                    if (ImGui::Combo("Layer", &current_item, layer_names.data(), layer_names.size()))
                                    {
                                        getFeatures->setLayerName(layer_names[current_item]);
                                        updateNodeGraph();
                                    }
                                }
                                else
                                {
                                    ImGui::TextColored(ImVec4(1,0,0,1), "No feature layers in map");
                                }

                                ImGui::PopItemWidth();
                            }

                            JoinFeaturesOperation* join = dynamic_cast<JoinFeaturesOperation*>(o.get());
                            if (join)
                            {
                                ImGui::PushItemWidth(100.0f);

                                std::string layerName = join->getLayerName();
                                static char layerNameChar[1024];
                                strcpy(layerNameChar, layerName.c_str());
                                if (ImGui::InputText("Layer", layerNameChar, IM_ARRAYSIZE(layerNameChar)))
                                {
                                    join->setLayerName(std::string(layerNameChar));
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            SimplifyOperation* simplifyOp = dynamic_cast<SimplifyOperation*>(o.get());
                            if (simplifyOp)
                            {
                                ImGui::PushItemWidth(100.0f);

                                bool dirty = false;
                                float sampleRatio = simplifyOp->getSampleRatio();
                                if (ImGui::SliderFloat("Sample Ratio", &sampleRatio, 0.1, 1.0f))
                                {
                                    simplifyOp->setSampleRatio(sampleRatio);
                                    dirty = true;
                                }

                                float maximumError = simplifyOp->getMaximumError();
                                if (ImGui::InputFloat("Maximum Error", &maximumError))
                                {
                                    simplifyOp->setMaximumError(maximumError);
                                    dirty = true;
                                }

                                float maximumLength = simplifyOp->getMaximumLength();
                                if (ImGui::InputFloat("Maximum Length", &maximumLength))
                                {
                                    simplifyOp->setMaximumLength(maximumLength);
                                    dirty = true;
                                }

                                if (dirty)
                                {
                                    updateNodeGraph();
                                }

                                ImGui::PopItemWidth();
                            }

                            TransformOperation* transformOp = dynamic_cast<TransformOperation*>(o.get());
                            if (transformOp)
                            {
                                ImGui::PushItemWidth(400.0f);

                                bool dirty = false;

                                if (ImGui::InputScalarN("Translation", ImGuiDataType_Double, transformOp->translation._v, 3))
                                {
                                    dirty = true;
                                }

                                if (ImGui::InputScalarN("Rotation", ImGuiDataType_Double, transformOp->rotation._v, 3))
                                {
                                    dirty = true;
                                }

                                if (ImGui::InputScalarN("Scale", ImGuiDataType_Double, transformOp->scale._v, 3))
                                {
                                    dirty = true;
                                }


                                if (dirty)
                                {
                                    updateNodeGraph();
                                }

                                ImGui::PopItemWidth();
                            }


                            RandomPointsOperation* randomPoints = dynamic_cast<RandomPointsOperation*>(o.get());
                            if (randomPoints)
                            {
                                int count = randomPoints->getCount();
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::InputInt("Count", &count))
                                {
                                    randomPoints->setCount(count);;
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            GriddedPointsOperation* griddedPoints = dynamic_cast<GriddedPointsOperation*>(o.get());
                            if (griddedPoints)
                            {
                                int count = griddedPoints->getCount();
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::InputInt("Count", &count))
                                {
                                    griddedPoints->setCount(count);;
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            PointsOnEdgeOperation* pointsOnEdge = dynamic_cast<PointsOnEdgeOperation*>(o.get());
                            if (pointsOnEdge)
                            {
                                int count = pointsOnEdge->getCount();
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::InputInt("Count", &count))
                                {
                                    pointsOnEdge->setCount(count);;
                                    updateNodeGraph();
                                }

                                ImGui::PopItemWidth();
                            }

                            ComparisonOperator* comparisonOperator = dynamic_cast<ComparisonOperator*>(o.get());
                            if (comparisonOperator)
                            {
                                ComparisonOperator::Comparison c = comparisonOperator->getComparison();
                                ImGui::PushItemWidth(100.0f);

                                const char* items[] = { ">", ">=", "<", "<=", "==", "!=" };
                                int item_current = c;
                                if (ImGui::Combo("Comparison", &item_current, items, IM_ARRAYSIZE(items)))
                                {
                                    c = (ComparisonOperator::Comparison)item_current;
                                    comparisonOperator->setComparison(c);
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            PlaceNodesOperation* placeNodes = dynamic_cast<PlaceNodesOperation*>(o.get());
                            if (placeNodes)
                            {
                                float scale[] = { placeNodes->getMinScale(), placeNodes->getMaxScale() };
                                ImGui::PushItemWidth(200.0f);
                                if (ImGui::InputFloat2("Scale Range", scale))
                                {
                                    placeNodes->setMinScale(scale[0]);
                                    placeNodes->setMaxScale(scale[1]);
                                    updateNodeGraph();
                                }

                                float heading[] = { placeNodes->getMinHeading(), placeNodes->getMaxHeading() };
                                ImGui::PushItemWidth(200.0f);
                                if (ImGui::InputFloat2("Heading Range", heading))
                                {
                                    placeNodes->setMinHeading(heading[0]);
                                    placeNodes->setMaxHeading(heading[1]);
                                    updateNodeGraph();
                                }

                                ImGui::PopItemWidth();
                            }

                            RandomValuePerFeature* randomValuePerFeature = dynamic_cast<RandomValuePerFeature*>(o.get());
                            if (randomValuePerFeature)
                            {
                                float range[] = { randomValuePerFeature->getMinValue(), randomValuePerFeature->getMaxValue() };
                                ImGui::PushItemWidth(200.0f);
                                if (ImGui::InputFloat2("Scale Range", range))
                                {
                                    randomValuePerFeature->setMinValue(range[0]);
                                    randomValuePerFeature->setMaxValue(range[1]);
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            PolygonToPointsOperation* polygonsToPoints = dynamic_cast<PolygonToPointsOperation*>(o.get());
                            if (polygonsToPoints)
                            {
                                bool random = polygonsToPoints->getRandom();
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::Checkbox("Random", &random))
                                {
                                    polygonsToPoints->setRandom(random);
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            FilterFeaturesOperation* filterFeatures = dynamic_cast<FilterFeaturesOperation*>(o.get());
                            if (filterFeatures)
                            {
                                ImGui::PushItemWidth(200);
                                std::string attribute = filterFeatures->getAttribute();
                                static char attributeChar[1024];
                                strcpy(attributeChar, attribute.c_str());
                                if (ImGui::InputText("Attribute", attributeChar, IM_ARRAYSIZE(attributeChar)))
                                {
                                    filterFeatures->setAttribute(std::string(attributeChar));
                                    updateNodeGraph();
                                }

                                std::string value = filterFeatures->getValue();
                                static char valueChar[1024];
                                strcpy(valueChar, value.c_str());
                                if (ImGui::InputText("Value", valueChar, IM_ARRAYSIZE(valueChar)))
                                {
                                    filterFeatures->setValue(std::string(valueChar));
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }

                            if (auto* op = dynamic_cast<SelectFeaturesOperation*>(o.get()))
                            {
                                ImGui::PushItemWidth(600);
                                auto code = op->_expression;

                                ImGui::Text("Javascript expression:");
                                if (ImGuiEx::InputTextMultiline("##select_features", &code, ImVec2(600, 200)))
                                {
                                    op->_expression = code;
                                    //updateNodeGraph(); // Force the user to click update
                                }

                                ImGui::PopItemWidth();
                            }

                            if (auto* op = dynamic_cast<BufferOperation*>(o.get()))
                            {

                                int quadSegs = op->getNumQuadSegs();
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::InputInt("Quad Segments", &quadSegs))
                                {
                                    op->setNumQuadSegs(quadSegs);;
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();

                                ImGui::PushItemWidth(100.0f);
                                const char* items[] = { "Flat", "Square", "Round"};
                                int item_current = static_cast<int>(op->getCapStyle());
                                if (ImGui::Combo("Cap Style", &item_current, items, IM_ARRAYSIZE(items)))
                                {
                                    op->setCapStyle(static_cast<Stroke::LineCapStyle>(item_current));
                                    updateNodeGraph();
                                }


                                ImGui::PushItemWidth(100.0f);
                                bool singleSided = op->getSingleSided();
                                if (ImGui::Checkbox("Single Sided", &singleSided))
                                {
                                    op->setSingleSided(singleSided);
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();

                                
                                ImGui::PopItemWidth();
                            }

                            if (auto* op = dynamic_cast<OffsetCurveOperation*>(o.get()))
                            {                                
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::InputInt("Quad Segments", &op->quadSegs))
                                {                                    
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();

                                ImGui::PushItemWidth(100.0f);
                                const char* items[] = { "Round", "Mitre", "Bevel" };
                                int item_current = static_cast<int>(op->joinStyle);
                                if (ImGui::Combo("Join Style", &item_current, items, IM_ARRAYSIZE(items)))
                                {
                                    op->joinStyle = static_cast<BufferParameters::JoinStyle>(item_current);
                                    updateNodeGraph();
                                }

                                float v = op->mitreLimit;
                                ImGui::PushItemWidth(100.0f);
                                if (ImGui::InputFloat("Mitre Limit", &v, 0.0f, 0.0f, "%.5f"))
                                {
                                    op->mitreLimit;
                                    updateNodeGraph();
                                }
                                ImGui::PopItemWidth();
                            }


                            for (auto& attr : o->getInputAttributes())
                            {
                                ImNodes::BeginInputAttribute(attr.getId());
                                ImGui::Text(attr.getName().c_str());
                                ImNodes::EndInputAttribute();
                            }

                            for (auto& attr : o->getOutputAttributes())
                            {
                                ImNodes::BeginOutputAttribute(attr.getId());
                                ImGui::Text(attr.getName().c_str());
                                ImNodes::EndOutputAttribute();
                            }


#if 0
                            ImGui::PushItemWidth(200.0f);
                            std::string comment = o->getComment();
                            if (ImGui::InputText("Comment", &comment))
                            {
                                o->setComment(comment);
                            }
                            ImGui::PopItemWidth();
#endif


                            ImNodes::EndNode();
                        }                    

                        // Draw all the links
                        for (auto& o : _proceduralModelLayer->getNodeGraph()->operations)
                        {
                            for (auto& link : o->getLinks())
                            {
                                ImNodes::Link(link.getId(), link._sourceAttribute->getId(), link._destinationAttribute->getId());
                            }
                        }
                    }
                    
                    ImNodes::EndNodeEditor();    

                    int start_attr, end_attr;
                    if (ImNodes::IsLinkCreated(&start_attr, &end_attr))
                    {
                        NodeGraphOperation* startOperation = nullptr;
                        const NodeAttribute* startAttribute = nullptr;

                        NodeGraphOperation* endOperation = nullptr;
                        const NodeAttribute* endAttribute = nullptr;
                        
                        std::cout << "Creating link between " << start_attr << " and " << end_attr << std::endl;

                        // Find the input attribute
                        for (auto& o : _proceduralModelLayer->getNodeGraph()->operations)
                        {
                            for (auto& attr : o->getInputAttributes())
                            {                             
                                if (attr.getId() == end_attr)
                                {
                                    endOperation = o.get();
                                    endAttribute = &attr;
                                }
                            }

                            for (auto& attr : o->getOutputAttributes())
                            {
                                if (attr.getId() == start_attr)
                                {
                                    startOperation = o.get();
                                    startAttribute = &attr;
                                }
                            }
                        }

                        if (startOperation && startAttribute && endOperation && endAttribute)
                        {
                            startOperation->connect(startAttribute->getName(), endOperation, endAttribute->getName());
                        }


                        updateNodeGraph();
                    }

                    int link_id;
                    if (ImNodes::IsLinkDestroyed(&link_id))
                    {
                        for (auto& o : _proceduralModelLayer->getNodeGraph()->operations)
                        {
                            for (auto itr = o->getLinks().begin(); itr != o->getLinks().end(); ++itr)
                            {
                                if (itr->getId() == link_id)
                                {
                                    o->getLinks().erase(itr);
                                    updateNodeGraph();
                                    break;
                                }
                            }
                        }
                    }

                    if (ImGui::IsKeyPressed(ImGuiKey_Delete))
                    {
                        static int selected_items[256];
                        if (ImNodes::NumSelectedNodes() > 0)
                        {
                            ImNodes::GetSelectedNodes(selected_items);
                            for (int i = 0; i < ImNodes::NumSelectedNodes(); i++)
                            {
                                for (auto itr = _proceduralModelLayer->getNodeGraph()->operations.begin(); itr != _proceduralModelLayer->getNodeGraph()->operations.end(); ++itr)
                                {
                                    if ((*itr)->getId() == selected_items[i])
                                    {
                                        _proceduralModelLayer->getNodeGraph()->operations.erase(itr);
                                        break;
                                    }
                                }
                            }
                            updateNodeGraph();
                        }

                        if (ImNodes::NumSelectedLinks() > 0)
                        {
                            ImNodes::GetSelectedLinks(selected_items);
                            for (int i = 0; i < ImNodes::NumSelectedLinks(); i++)
                            {
                                for (auto& o : _proceduralModelLayer->getNodeGraph()->operations)
                                {
                                    for (auto itr = o->getLinks().begin(); itr != o->getLinks().end(); ++itr)
                                    {
                                        if (itr->getId() == selected_items[i])
                                        {
                                            o->getLinks().erase(itr);
                                            break;
                                        }
                                    }
                                }
                            }
                            updateNodeGraph();
                        }
                    }
                }
                ImGui::End();
            }
        };
    }
}
